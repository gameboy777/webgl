1、WebGL 是一组基于 JavaScript 语言的图形规范，浏览器厂商按照这组规范进行实现，为 Web 开发者提供一套3D图形相关的 API。这些 API 能够让 Web 开发者使用 JavaScript 语言直接和显卡（GPU）进行通信。当然 WebGL 的 GPU 部分也有对应的编程语言，简称 GLSL。我们用它来编写运行在 GPU 上的着色器程序。着色器程序需要接收 CPU（WebGL 使用 JavaScript） 传递过来的数据，然后对这些数据进行流水线处理，最终显示在屏幕上。
  3D 模型数据从诞生到最终显示在屏幕上，这期间经历了什么样的过程呢？大家可以想象一下流水线的生产过程，流水线按照既定的步骤对原料进行加工，当前步骤只对前一步骤的结果进行处理，然后将处理后的结果传递给下一步骤，最终将原材料生产成完整的产品。WebGL 的工作方式和流水线类似，也是按照流水线的方式将 3D 模型数据渲染到 2D 屏幕上的，业界把这种渲染方式称为图形管线或者渲染管线。

1、一般情况下，最初的顶点坐标是相对于模型中心的，不能直接传递到着色器中，我们需要对顶点坐标按照一系列步骤执行模型转换，视图转换，投影转换，转换之后的坐标才是 WebGL 可接受的坐标，即裁剪空间坐标。我们把最终的变换矩阵和原始顶点坐标传递给 GPU，GPU 的渲染管线对它们执行流水线作业。

2、GPU 渲染管线的主要处理过程如下：
  1、首先进入顶点着色器阶段，利用 GPU 的并行计算优势对顶点逐个进行坐标变换。
  2、然后进入图元装配阶段，将顶点按照图元类型组装成图形。
  3、接下来来到光栅化阶段，光栅化阶段将图形用不包含颜色信息的像素填充。在光栅化阶段，GPU 处理两件事情：
    计算图元覆盖了哪些像素。
    根据顶点着色器的顶点位置计算每个像素的纹理坐标的插值。
  4、在之后进入片元着色器阶段，该阶段为像素着色，并最终显示在屏幕上。
    光栅化结束后，来到片元着色器，片元着色器此时知道每个像素对应的 UV 坐标，根据当前像素的 UV 坐标，找到纹理资源对应坐标的颜色信息，赋值给当前像素，从而能够为图元表面的每个像素贴上正确的纹理颜色。

3、我们需要使用 JavaScript 声明 WebGL 运行的载体 canvas，设置 canvas 的初始大小，获取 WebGL 的上下文，对模型顶点的坐标、颜色、法向量等信息进行处理，并将这些处理好的数据传递给 GPU 。对于复杂的 WebGL 应用，顶点、纹理、光照等数据甚至需要从外部模型文件中获取，所以我们还需要用 JavaScript 解析加载模型数据。

4、GLSL 的中文意思是 OpenGL 着色语言，英文全称是 OpenGL Shading Language，它是用来在 OpenGL 编写着色器程序的语言。着色器程序是在显卡（GPU）上运行的简短程序，代替了 GPU 固定渲染管线的一部分，使 GPU 渲染过程中的某些部分允许开发者通过编程进行控制。着色器程序允许我们通过编程来控制 GPU 的渲染。GLSL 本质上是在 C 语言的基础上，增加了一些数据类型和数学函数。
  注意，GLSL 是强类型语言，定义变量时，数据类型和值一定要匹配正确，比如我们给浮点数 a 赋值 1，我们需要这样写：float a = 1.0; 如果用 float a = 1; 的话会报错。

5、实际上，对顶点信息的变换操作既可以在 JavaScript 中进行，也可以在着色器程序中进行。通常我们都是在 JavaScript 中生成一个包含了所有变换的最终变换矩阵，然后将该矩阵传递给着色器，利用 GPU 并行计算优势对所有顶点执行变换。

5、相关术语
  1、图元：WebGL 能够绘制的基本图形元素，包含三种：点、线段、三角形。
  2、片元：可以理解为像素，像素着色阶段是在片元着色器中。
  3、裁剪坐标系：裁剪坐标系是顶点着色器中的 gl_Position 内置变量接收到的坐标所在的坐标系。
  4、设备坐标系：又名 NDC 坐标系，是裁剪坐标系各个分量对 w 分量相除得到的坐标系，特点是 x、y、z 坐标分量的取值范围都在 【-1，1】之间，可以将它理解为边长为 2 的正方体，坐标系原点在正方体中心。

6、gl_Position、gl_PointSize、gl_FragColor 是 GLSL 的内置属性。
  1、gl_Position：顶点的裁剪坐标系坐标，包含 X, Y, Z，W 四个坐标分量，顶点着色器接收到这个坐标之后，对它进行透视除法，即将各个分量同时除以 W，转换成 NDC 坐标，NDC 坐标每个分量的取值范围都在【-1, 1】之间，GPU 获取这个属性值作为顶点的最终位置进行绘制。
    GLSL 中 gl_Position 所接收的坐标所在坐标系是裁剪坐标系 ，不同于我们的浏览器窗口坐标系。所以当我们赋予 gl_Position 位置信息的时候，需要对其进行转换才能正确显示。
    gl_Position 接收一个 4 维浮点向量，该向量代表的是裁剪坐标系的坐标。gl_Position 接收的坐标范围是顶点在裁剪坐标系中的坐标。裁剪坐标系中的坐标通常由四个分量表示：(x, y, z, w)。请注意，w 分量代表齐次坐标分量，在之前的例子中，w 都是设置成 1 ，这样做的目的是让裁剪坐标系和 NDC 坐标系就保持一致，省去裁剪坐标到 NDC 坐标的转换过程。
    gl_Position 接收到裁剪坐标之后，顶点着色器会对坐标进行透视除法，透视除法的公式是 (x/w, y/w, z/w, w/w) ，透视除法过后，顶点在裁剪坐标系中的坐标就会变成 NDC 坐标系中的坐标，各个坐标的取值范围将被限制在【-1，1】之间，如果某个坐标超出这个范围，将会被 GPU 丢弃。
    给 gl_Position 赋的坐标，在 渲染到屏幕之前，GPU 还会对其做一次坐标变换：视口变换。该变换会将 NDC 坐标转换成对应设备的视口坐标。
    请注意：gl_Position 接收一个 4 维向量表示的坐标，即(X, Y ,Z ,W)，W 不等于 0，这个坐标是在裁剪坐标系中，我们称它为裁剪坐标。
    GPU 得到裁剪坐标后，下一步会对坐标进行透视除法。所谓透视除法就是将裁剪坐标的各个分量同时除以 W 分量，使得 W 分量为 1。经过透视除法得到的坐标便处在 NDC 坐标系（设备独立坐标系）中， NDC 坐标系是一个边长为 2 的正方体，超出正方体的顶点都将被抛弃，不会显示到屏幕上。在 NDC 坐标系内的坐标都会落在【-1，1】之间，因此很多顶点坐标往往都是小数。
    接下来，GPU 就要将顶点绘制到屏幕上了，顶点此时的坐标已经转变到 NDC 坐标系中，但是 NDC 坐标系和屏幕坐标系不一致，所以就产生了最后一个坐标变换，视口转换，将顶点坐标从 NDC 坐标系下转换到屏幕坐标系下的坐标，最终将顶点显示在屏幕指定位置上。
  2、gl_FragColor：片元（像素）颜色，包含 R, G, B, A 四个颜色分量，且每个分量的取值范围在【0,1】之间，GPU 获取这个值作为像素的最终颜色进行着色。
    gl_FragColor，属于 GLSL 内置属性，用来设置片元颜色，包含 4 个分量 (R, G, B, A)，各个颜色分量的取值范围是【0，1】，也不同于我们常规颜色的【0，255】取值范围，所以当我们给 gl_FragColor 赋值时，也需要对其进行转换。平常我们所采用的颜色值（R, G, B, A），对应的转换公式为： (R值/255，G值/255，B值/255，A值/1）。拿红色举例，在CSS中，红色用 RGBA 形式表示是（255，0，0，1），那么转换成 GLSL 形式就是(255 / 255, 0 / 255, 0 / 255, 1 / 1)，转换后的值为（1.0, 0.0, 0.0, 1.0)。
  3、gl_PointSize：绘制到屏幕的点的大小，需要注意的是，gl_PointSize只有在绘制图元是点的时候才会生效。当我们绘制线段或者三角形的时候，gl_PointSize是不起作用的。
  4、vec4：包含四个浮点元素的容器类型，vec 是 vector（向量）的单词简写，vec4 代表包含 4 个浮点数的向量。此外，还有 vec2、vec3 等类型，代表包含2个或者3个浮点数的容器。
  5、gl.drawArrays 是执行绘制的 API，上面示例中的第一个参数 gl.POINTS 代表我们要绘制的是点图元，第二个参数代表要绘制的顶点的起始位置，第三个参数代表顶点绘制个数。void gl.drawArrays(mode, first, count);
    mode，代表图元类型。
    first，代表从第几个点开始绘制。
    count，代表绘制的点的数量。
  6、变量类型
    1、attribue 变量：只能在顶点着色器中定义。
    2、uniform 变量：既可以在顶点着色器中定义，也可以在片元着色器中定义。全局变量 (被 uniform 修饰的变量)
    3、最后一种变量类型 varing 变量：它用来从顶点着色器中往片元着色器传递数据。使用它我们可以在顶点着色器中声明一个变量并对其赋值，经过插值处理后，在片元着色器中取出插值后的值来使用。
  7、precision：精度设置限定符，使用此限定符设置完精度后，之后所有该数据类型都将沿用该精度，除非单独设置。
  8、运算符：向量的对应位置进行运算，得到一个新的向量。
    1、vec * 浮点数： vec2(x, y) * 2.0 = vec(x * 2.0, y * 2.0)。
    2、vec2 * vec2：vec2(x1, y1) * vec2(x2, y2) = vec2(x1 * x2, y1 * y2)。
    3、加减乘除规则基本一致。但是要注意一点，如果参与运算的是两个 vec 向量，那么这两个 vec 的维数必须相同。
  9、JavaScript 程序如何连接着色器程序
    createShader：创建着色器对象
    shaderSource：提供着色器源码
    compileShader：编译着色器对象
    createProgram：创建着色器程序
    attachShader：绑定着色器对象
    linkProgram：链接着色器程序
    useProgram：启用着色器程序
  10、JavaScript 如何往着色器中传递数据
    getAttribLocation：找到着色器中的 attribute 变量地址。
    getUniformLocation：找到着色器中的 uniform 变量地址。
    vertexAttrib2f：给 attribute 变量传递两个浮点数。
    uniform4f：给uniform变量传递四个浮点数。
  11、gl.STATIC_DRAW 提示 WebGL 我们不会频繁改变缓冲区中的数据，WebGL 会根据这个参数做一些优化处理。
  12、使用缓冲区传递数据。
    gl.createBuffer：创建buffer。
    gl.bindBuffer：绑定某个缓冲区对象为当前缓冲区。
    gl.bufferData：往缓冲区中复制数据。
    gl.enableVertexAttribArray：启用顶点属性。
    gl.vertexAttribPointer：设置顶点属性从缓冲区中读取数据的方式。
    首先创建一个缓冲区（var buffer = gl.createBuffer()）；缓冲区创建好了，我们绑定该缓冲区为 WebGL 当前缓冲区 gl.ARRAY_BUFFER；绑定之后，对缓冲区绑定点的的任何操作都会基于该缓冲区（即buffer） 进行（gl.bindBuffer(gl.ARRAY_BUFFER, buffer)）；接下来往当前缓冲区（即上一步通过 bindBuffer 绑定的缓冲区）中写入数据（gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW)）。注意，着色器程序中的变量需要强类型数据，所以我们在往缓冲区写数据的时候，JS 的弱类型数组一定要用类型化数组转化一下。上面的 new Float32Array(positions)，目的就是将 JavaScript 中的弱类型数组转化为强类型数组。最后一个参数 gl.STATIC_DRAW 提示 WebGL 我们不会频繁改变缓冲区中的数据，WebGL 会根据这个参数做一些优化处理。
    我们需要告诉 WebGL 如何从之前创建的缓冲区中获取数据，并且传递给顶点着色器中的 a_Position 属性。 那么，首先启用对应属性 a_Position（gl.enableVertexAttribArray(a_Position)）；接下来我们需要设置从缓冲区中取数据的方式（gl.vertexAttribPointer(
   a_Position, size, type, normalize, stride, offset)）。需要注意的是，我们通过 gl.vertexAttribPointer 将属性绑定到了当前的缓冲区，即使之后我们使用 bindBuffer 绑定到其他缓冲区时，a_Position 也依然会从 buffer 这个缓冲区中获取数据。
  13、WebGL 除了提供 gl.drawArrays 按顶点绘制的方式以外，还提供了一种按照顶点索引进行绘制的方法：gl.drawElements，使用这种方式，可以避免重复定义顶点，进而节省存储空间。void gl.drawElements(mode, count, type, offset);
    mode：指定绘制图元的类型，是画点，还是画线，或者是画三角形。
    count：指定绘制图形的顶点个数。
    type：指定索引缓冲区中的值的类型,常用的两个值：gl.UNSIGNED_BYTE和gl.UNSIGNED_SHORT，前者为无符号8位整数值，后者为无符号16位整数。
    offset：指定索引数组中开始绘制的位置，以字节为单位。
  14、开启背面剔除功能：gl.enable(gl.CULL_FACE);
    也可以更改面的显示方式，默认显示正面，我们可以通过如下方式，剔除背面，只显示正面：gl.cullFace(gl.FRONT);
  15、glTexImage2D(GLenum target, GLint level, GLint components, GLsizei width, glsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
    target	纹理类型，TEXTURE_2D代表2维纹理
    level	表示多级分辨率的纹理图像的级数，若只有一种分辨率，则 level 设为 0，通常我们使用一种分辨率
    components	纹理通道数，通常我们使用 RGBA 和 RGB 两种通道
    width	纹理宽度，可省略
    height	纹理高度，可省略
    border	边框，通常设置为0，可省略
    format	纹理映射的格式
    type	纹理映射的数据类型
    pixels	纹理图像的数据
  16、gl.LINEAR 代表采用最靠近象素中心的四个象素的加权平均值，这种效果表现的更加平滑自然。 gl.NEAREST 采用最靠近象素中心的纹素，该算法可能使图像走样，但是执行效率高，不需要额外的计算。


7、注意，GLSL 是强类型语言，定义变量时，数据类型和值一定要匹配正确，比如我们给浮点数 a 赋值 1，我们需要这样写：float a = 1.0; 如果用 float a = 1; 的话会报错。

8、注意，着色器程序中的变量需要强类型数据，所以我们在往缓冲区写数据的时候，JS 的弱类型数组一定要用类型化数组转化一下。上面的 new Float32Array(positions)，目的就是将 JavaScript 中的弱类型数组转化为强类型数组。

9、gl.vertexAttribPointer 将属性绑定到了当前的缓冲区，即使之后我们使用 bindBuffer 绑定到其他缓冲区时，a_Position 也依然会从buffer这个缓冲区中获取数据。gl.vertexAttribPointer (target, size, type, normalize, stride, offset)。
  1、target： 允许哪个属性读取当前缓冲区的数据。
  2、size：一次取几个数据赋值给 target 指定的目标属性。在我们的示例中，顶点着色器中 a_Position 是 vec2 类型，即每次接收两个数据，所以 size 设置为 2。以后我们绘制立体模型的时候，a_Position 会接收三个数据，size 相应地也会设置成 3。
    以多少元素作为一个顶点信息进行读取的设置，是在调用 gl.vertexAttribPointer 时设置的 size 参数值。
  3、type：数据类型，一般而言都是浮点型。
  4、normalize：是否需要将非浮点类型数据单位化到【-1, 1】区间。
  5、stride：步长，即每个顶点所包含数据的字节数，默认是 0 ，0 表示一个属性的数据是连续存放的。在我们的例子中，我们的一个顶点包含两个分量，X 坐标和 Y 坐标，每个分量都是一个 Float32 类型，占 4 个字节，所以，stride = 2 * 4 = 8 个字节。但我们的例子中，缓冲区只为一个属性a_Position服务，缓冲区的数据是连续存放的，因此我们可以使用默认值 0 来表示。但如果我们的缓冲区为多个属性所共用，那么 stride 就不能设置为 0 了，需要进行计算。
  6、offset：在每个步长的数据里，目标属性需要偏移多少字节开始读取。在我们的例子中，buffer 只为 a_Position 一个属性服务，所以 offset 为 0 * 4 = 0。

10、请谨记：程序中如果有多个 buffer 的时候，在切换 buffer 进行操作时，一定要通过调用 gl.bindBuffer 将要操作的 buffer 绑定到 gl.ARRAY_BUFFER 上，这样才能正确地操作 buffer 。您可以将 bindBuffer 理解为一个状态机，bindBuffer 之后的对 buffer 的一些操作，都是基于最近一次绑定的 buffer 来进行的。以下 buffer 的操作需要在绑定 buffer 之后进行：
  gl.bufferData：传递数据。
  gl.vertexAttribPointer：设置属性读取 buffer 的方式。

11、请谨记，组成三角形的顶点要按照一定的顺序绘制。默认情况下，WebGL 会认为顶点顺序为逆时针时代表正面，反之则是背面，区分正面、背面的目的在于，如果开启了背面剔除功能的话，背面是不会被绘制的。当我们绘制 3D 形体的时候，这个设置很重要。

12、WebGL 坐标系 X、Y、Z 三个坐标分量的的范围是【-1，1】，即一个边长为 2 的正方体，原点在正方体中心。我们称这个坐标系为标准设备坐标系，简称 NDC 坐标系。

13、引入模型变换让立方体可以转动，以便我们能观察其他表面。引入投影变换让我们的正方体能够以正常比例渲染到目标设备，不再随视口的变化而拉伸失真。

14、WebGL 的开发步骤
  1、初始化阶段
    创建所有着色器程序。
    寻找全部 attribute 参数位置。
    寻找全部 uniforms 参数位置。
    创建缓冲区，并向缓冲区上传顶点数据。
    创建纹理，并上传纹理数据。
  2、首次渲染阶段
    为 uniforms 变量赋值。
    处理 attribute 变量
      使用 gl.bindBuffer 重新绑定模型的 attribute 变量。
      使用 gl.enableVertexAttribArray 启用 attribute 变量。
      使用 gl.vertexAttribPointer设置 attribute变量从缓冲区中读取数据的方式。
      使用 gl.bufferData 将数据传送到缓冲区中。
    使用 gl.drawArrays 执行绘制。
  3、后续渲染阶段
    对发生变化的 uniforms 变量重新赋值。
    每个模型的 attribute 变量。
      使用 gl.bindBuffer 重新绑定模型的 attribute 变量。
      使用 gl.bufferData 重新向缓冲区上传模型的 attribute 数据。
    使用 gl.drawArrays 执行绘制。

15、GLSL 语法
  1、变量命名
    GLSL 的语法和 C 语言类似，因此 GLSL 的变量命名方式和 C 语言基本一致。但由于 GLSL 新增了一些数据类型、内置属性和保留前缀，所以变量命名除了满足 C 语言的命名规则之外，还要满足 GLSL 的特殊规则：
      1、不能以 gl_ 作为前缀，gl_ 开头的变量被用于定义 GLSL 的内部变量，这是 GLSL 保留的命名前缀。
      2、GLSL 的一些保留名称也不能作为变量名称，比如 attribute、uniform、varying 等。
  2、数据类型
    GLSL 最突出的部分是新增了向量和矩阵相关的数据类型，比如存储向量的容器 vec{n}，存储四阶矩阵的容器mat4，2D纹理采样器 sampler2D，3D纹理采样器samplerCube等等。
      1、向量
        向量是 GLSL 中很重要的一种数据类型，着色器程序的很多地方都需要用到向量，用来储存包含多个分量的数据，比如颜色信息、齐次坐标、法向量等。
        向量按照维度分为2维、3维、4维，按照存储的数据类型分为浮点向量vec{n}，整型向量ivec{n}，布尔向量bvec{n}。
        vec 向量类型会自动对元素做类型转换。
        每个向量我们都可以用 {s、t、p、q},{r、g、b、a},{x、y、z、w}来表示。获取各个位置的元素，我们可以使用.操作符。
        向量和向量之间也可以进行运算，返回一个新的向量，前提是两个向量之间的维度必须相同。运算规则是两个向量对应位置的元素分别进行运算。
        GLSL 中增加了两种内置函数，用来实现点乘和叉乘运算，它们分别是 dot和cross，使用起来也很简单：
          // 点乘
          vec3 v3 = dot(v1, v2);
          向量点乘就是将两个向量的各个分量的乘积相加，返回一个标量。点乘的几何意义是两个向量的模相乘然后再乘以夹角的余弦。所以，我们经常会用点乘来计算两个向量之间的夹角大小，比如在光照模型中，我们在计算漫反射分量时，就使用了点乘公式，求出入射光和法向量之间夹角的大小，通常只求夹角的话，一般先将两个向量归一化，这样就不用再去计算向量模了，直接取点乘结果即可。比如在计算光照时，判断物体表面是否被光源照射，就是通过法向量和光源入射光线的点积来判断，为正表示光源在表面正面，能被照射到，为负表示光源在表面背面，不能被照到。
          // 叉乘
          vec3 v3 = cross(v1, v2);
          a向量 * b向量 = (y0z1 - y1z0, x1z0 - x0z1, x0y1 - x1y0);
          向量叉乘是另一个重要的运算，两个向量叉乘结果是一个新向量，新向量的方向垂直于原来两个向量所在的平面，方向可以通过右手定则来判定（利用右手定则，当右手的四指从向量 a 以不超过 180 度的转角转向 b 时，竖起的大拇指指向是叉乘结果向量的方向。），大小等于两个向量模的乘积再乘以向量夹角的正弦值，即向量组成的平行四边形的面积。
        向量的大小，也就是向量的长度（也叫向量的模），通常用 |\vec{a}|来表示，向量的大小等于向量各个分量平方之和的平方根。
        向量不能和标量相加减，但是向量可以和标量相乘除，向量和标量相乘或者相除返回一个新向量，新向量的各个分量等于原向量的各个分量和标量的乘积或者商。
        单位向量是长度为 1 的向量，对于大部分向量，我们只关心向量的方向，而不在意向量的长度，这种情况下就适合用单位向量来表示。比如光线入射方向、反射方向等向量，单位向量通常也被称为标准向量。
        对于任意一个不为 0 的向量，我们都能将它转变成同方向的单位向量，这个转变过程我们称之为归一化向量或者标准化向量。
        归一化向量只需要将原向量除以原向量的长度（模）即可，一定要注意，原向量不能是零向量。
      2、矩阵
        矩阵是按照行列排列的一系列数值得的集合，一个矩阵通常是由 m 行 n 列组成，我们称之为 m * n矩阵，如果 m 和 n 相同，该矩阵代表一个方阵，我们就可称这个方阵为 m 阶矩阵(方阵)，矩阵一般用大写字母来表示。
        要注意，向量可以理解为一个特殊的矩阵，4 维向量既可以理解为一个 1 行 4 列矩阵，此时这个向量被称为行向量。也可以理解为一个 4 行 1 列矩阵，此时这个向量被称为列向量。
        两个矩阵相加或者相减需要满足一个条件，即两个矩阵必须同型，同型的意思是，行数和列数都必须一样。一个 m x n 矩阵 和一个 n x m 矩阵（m 不等于 n ）是不能进行加减的。如果满足了以上条件，矩阵加法和减法的运算只需将两个矩阵对应位置上的元素相加或相减即可，得到的新矩阵和原矩阵同型。
        矩阵与矩阵相乘也要满足一定条件，假设两个矩阵能够相乘：那么，他们之间必须满足以下条件：M 的列数等于 N 的行数。其次，一个 m 行 n 列矩阵 乘以 n 行 q 列矩阵，所得到的新矩阵为 m 行 q 列，即 m行n列 * n行q列 = m行q列。新矩阵的各个位置的值按照如下规则计算：矩阵 P 第 m 行 q 列位置的元素等于矩阵 M 第 m 行的各个分量和矩阵 N 第 q 列的各个分量的乘积之和。
        矩阵与向量相乘其实等价于矩阵与一阶矩阵相乘，其实质是将向量变换为另一个向量，但是要注意乘法的顺序。假设有一个4 维向量 P 和一个4 阶方阵 M，当 P 左乘 M 时，P 一定要表示成行向量，即 1 * 4 矩阵。当 P 右乘 M 时，P要表示成列向量，即 4 * 1 矩阵。
        假设有一个 m 阶方阵 A ，如果存在一个n 阶方阵 B，使得 A x B = B x A = I 其中 I 是单位矩阵，那么 B 是 A 的逆矩阵， A 矩阵就是可逆矩阵，也称非奇异矩阵。这里要说明一下什么是单位矩阵，单位矩阵首先是一个方阵，其次方阵对角线上的元素都为 1，其余元素为 0。但并不是所有矩阵都存在逆矩阵，逆矩阵首先必须是方阵，其次存在另一个矩阵与之相乘，能够得到一个单位矩阵。
        逆矩阵在图形学中有着非常重要的作用，在图形学中，将一个变换矩阵左乘一个列向量（此处列向量代表顶点坐标），代表了对原始顶点执行了某种变换，比如旋转、缩放、平移等。逆矩阵的意义就是能够撤销这种变换，将变换后的坐标再还原回去。
        假设有一个方阵M，当且仅当 M 与其转置矩阵的乘积等于单位矩阵时，称其为正交矩阵。正交矩阵的一个好处是，如果一个矩阵是正交矩阵，那么计算它的逆矩阵时，只需要对原矩阵转置即可，从而减少了计算量（逆矩阵的求解过程是很繁琐的），3D图形学中的最常见的旋转和镜像变换就都是正交的。
        判断一个矩阵 M 是否正交的重要条件是：M 的行向量是一个相互正交的单位向量组，什么意思呢？其实就是两个条件：矩阵的每一行都是单位向量；矩阵的某一行和其他行向量相互垂直，点积为 0。这两个条件可以利用MM^T=I公式来证明。利用这个充要条件可以快速判断一个矩阵是否是正交矩阵。同时也可以得到，如果M是正交矩阵，则M^T也是正交矩阵。
        四阶矩阵，包含 4 行 4 列共 16 个浮点数，在着色器程序中初始化一个四阶矩阵有很多种方式。
          1、用 16 个浮点数构造矩阵。
            mat4 m = mat4(
                1, 2, 3, 4,  //第一列
                5, 6, 7, 8,  //第二列
                9, 10, 11, 12, //第三列
                13, 14, 15,16 // 第四列
            );
          2、用 1 个浮点数构造对角线矩阵。
            mat4 a = mat4(1.0);
            mat4 传入一个浮点数构造出的矩阵，对角线上的值都是 1.0。
          3、利用列向量构造
            四阶矩阵可以理解为四个列向量组合而成，所以 GLSL 提供了利用向量构造矩阵的方法。
            //第一列
            vec4 c0 = vec4(1, 2, 3, 4);
            //第二列
            vec4 c1 = vec4(5, 6, 7, 8);
            //第三列
            vec4 c2 = vec4(1, 2, 3, 4);
            //第四列
            vec4 c3 = vec4(5, 6, 7, 8);
            mat4 m = mat4(c0, c1, c2, c4);
          4、向量与浮点数混合构造。 当然除了纯数字构造、纯向量构造，GLSL 也允许向量和数字混合构造：
            vec4 c0 = vec4(1, 2, 3, 4);
            vec4 c1 = vec4(5, 6, 7, 8);
            vec4 c2 = vec4(1, 2, 3, 4);
            mat4 m = mat4(c0, c1, c2, 5, 6, 7, 8);
        转置、求逆
          mat4 m0 = mat4(1.0);
          // 转置
          mat4 m1 = transpose(m0);
          // 求逆
          mat4 m2 = inverse(m0)
  3、内置变量
    gl_Position：顶点坐标。
    gl_PointSize：点的尺寸。
    gl_Normal：顶点法线。

    gl_FragColor，当前片元的颜色，类型 vec4。
    gl_FragCoord，屏幕像素的x，y，z，1 / w。
    gl_FragDepth，片元的最终深度值，在后面的深度测试用到，在片元着色器中我们无法修改x, y值，但是可以修改z值。
  4、内置函数
    1、向量函数
      cross	计算两个向量的叉积
      dot	计算向量的点积。
      normalize	归一化向量，返回一个和原向量方向相同，但是长度为1的单位向量。
      reflect	根据入射向量和法线向量，计算出反射向量。
      length	计算向量的长度
      distance	计算两个向量之间的距离。
    2、常用数学函数
      abs	将某个数的绝对值
      floor	返回不大于某个数的最大整数。
      round	四舍五入值
      ceil	返回大于某个数的最小整数。
      fract	返回浮点数的小数部分
      mod	取模
      min	返回两个数中比较小的数
      max	返回两个数中比较大的数
    3、三角函数
      radians	将角度（如90度）转化为弧度（PI/2）。
      degrees	将弧度（如PI / 2）转化为角度（90 度）。
      sin	求弧度的正弦
      cos	求弧度的余弦
      tan	求弧度的正切
      asin	根据正弦值求对应的弧度
      acos	根据余弦值求对应的弧度
      atan	根据正切值求对应的弧度
  5、限定符
    1、attribute
      attribute 变量只能定义在顶点着色器中，它的作用是接收 JavaScript 程序传递过来的与顶点有关的数据，比如在之前程序中定义的顶点颜色、法线、坐标等，它们是顶点的属性。
      也就是说，如果有一类数据，它是跟随顶点而存在的，每个顶点所对应的数据不尽相同，那么我们就需要用 attribute 限定符定义变量。
    2、uniform
      uniform 用来修饰全局变量，它既可以在顶点着色器中定义，也可以在片元着色器中定义，用来接收与顶点无关的数据。
      比如，在之前程序中，我们定义了一个 uniform 变量 u_Matrix，它用来接收 JavaScript 中传递过来的 模型视图投影矩阵，该数据与顶点无关，也就是每个顶点共用变换矩阵，所以我们应该用 uniform 修饰该变量。
    3、varying
      varying变量一般是成对定义的，即在顶点着色器中定义，在片元着色器中使用。它所修饰的变量在传递给片元着色器之前会进行插值化处理。
16、点在 3D 领域通常指顶点坐标，3D 世界由很多模型组成，模型又由很多面组成，而面又由很多点组成。因此，点是组成 3D 世界的基本元素。WebGL 渲染的过程，就是将组成模型的顶点传递给 GPU，GPU 按照指定图元装配并插值这些顶点数据，然后通过片元着色器对像素进行着色，最终渲染成 3D 模型。由此可见顶点是模型的起始数据，重要性可见一斑。
17、通常我们使用向量容器来表示数学中的点和向量。
  比如我们经常会使用 3 维向量来表示顶点坐标，3 维向量还可以理解为一个 3 x 1 阶矩阵，将 3 x 3 阶变换矩阵左乘顶点坐标（3 * 1 阶矩阵），按照矩阵的运算法则，m行n列 矩阵左乘 n 行 o 列矩阵可以得到一个 m 行 o 列矩阵，所以我们矩阵和向量相乘结果是一个新的 3 * 1 阶 矩阵，也就是 3 维向量，它表示变换后的顶点坐标。
  通常在对模型执行坐标转换的时候，变换矩阵左乘顶点坐标代表对这个顶点执行坐标转换，这是顶点着色器中对顶点执行的最常用的操作。
  又比如在为模型表面计算光照强度的时候，我们会用到法向量和光线入射向量，利用他们之间的点积计算光照强度。
18、vec3 p = vec3(x, y, z);
  如何判断 P 代表向量还是代表顶点坐标呢？
  通常使用齐次坐标系来解决这种混乱。齐次坐标系使用 N + 1 维向量来表示 N 维点坐标和 N 维向量。假设在 3 维坐标系中，有一个点(X, Y, Z)，那么在齐次坐标系中会使用 4 维向量来表示它 (X, Y, Z, W)。注意：W > 0。如果是向量的话，齐次坐标将向量表示为(X, Y, Z, 0)。
  请谨记：W 为 0 时代表向量。W 不为 0 代表点。
  齐次坐标系的引入除了解决这种概念混乱，还有一个重要的作用，透视除法。
19、坐标系分类
  为了将模型坐标转换成裁剪坐标，我们增加了坐标转换流水线。顶点坐标起始于模型坐标系，在这里它被称为模型坐标。模型坐标在 CPU 中经过一系列坐标系变换，生成裁剪坐标，之后 CPU 将裁剪坐标传递给 GPU。
  WebGL坐标系分为如下几类：模型坐标系 -- 世界坐标系 -- 观察坐标系（又称相机坐标系、视图坐标系） -- 裁剪坐标系（gl_Position接收的值） -- NDC 坐标系 -- 屏幕坐标系。其中，裁剪坐标系之前的这几个坐标系，我们都可以使用 JavaScript 控制。从裁剪坐标系到 NDC 坐标系，这一个步骤是 顶点着色器的最后自动完成的，我们无法干预。
  1、CPU 中将模型坐标转换成裁剪坐标
    顶点在模型坐标系中的坐标经过模型变换，转换到世界坐标系中。
    然后通过摄像机观察这个世界，将物体从世界坐标系中转换到观察坐标系。
    之后进行投影变换，将物体从观察坐标系中转换到裁剪坐标系。
  2、GPU 接收CPU 传递过来的裁剪坐标。
    接收裁剪坐标，通过透视除法，将裁剪坐标转换成 NDC 坐标。
    GPU 将 NDC 坐标通过视口变换，渲染到屏幕上。
  3、模型坐标系
    一个物体通常由很多点构成，每个点在模型的什么位置？我们需要用一个坐标系来参照，这个坐标系就叫模型坐标系，模型坐标系原点通常在模型的中心，各个坐标轴遵循右手坐标系，即 X 轴向右，Y 轴向上，Z 轴朝向屏幕外。
    一般在建模软件中创建模型的时候，各个顶点的坐标都是以模型的某一个点为参照点建立的。
  4、世界坐标系
    我们创建好的模型需要放置在世界中的各个位置，默认情况模型坐标系和世界坐标系重合。如果模型不在世界坐标系中心，那么就需要对模型坐标系进行转换，将模型的各个相对于模型中心的顶点坐标转换成世界坐标系下的坐标。
    世界坐标系也是遵循右手坐标系，X 轴水平向右，Y 轴垂直向上，Z 轴指向屏幕外面。
    假如模型中有一点 P ，相对于模型中心的坐标（1，1）。 该模型在世界坐标系的（3，0）位置，那么，顶点 P 在世界坐标系中的坐标就变成了（4，1）。
  5、观察坐标系
    观察坐标系是将世界空间坐标转化为用户视野前方的坐标而产生的结果。人眼或者摄像机看到的世界中的物体相对于他自身的位置所参照的坐标系就叫观察坐标系。
    在我们日常生活中，精准描述一个街道，我们一般用经纬度来表示，但是如果有人问你：某某街道在什么位置？如果我们告诉他世界坐标：某某街道在东经 M 度，北纬 N 度，我想他会打你。。
    一般我们都会用这样易于理解的描述：在前面多远，往左或右走多远。
    这种坐标就称为观察坐标，也叫相机坐标，他是以人眼/摄像机为原点而建立的坐标系。
    之所以有相机坐标系，是为了模仿人眼看待世界的效果。世界很大，有很多物体，但是不能把整个世界都显示到屏幕上，只显示人眼所能看到的一部分，这样我们就能通过改变人眼所处的方位，人眼所在的位置，看到整个 3D 空间的不同部分。
  6、裁剪坐标系
    裁剪坐标是将相机坐标进行投影变换后得到的坐标，也就是 gl_Position 接收的坐标，顾名思义，以裁剪坐标系为参照。
    裁剪坐标系遵循左手坐标系。
    相机坐标系观察的空间是整个 3D 世界，而裁剪坐标系是希望所有的坐标都落在一个特定的范围内，超出这个范围的顶点坐标都将被裁剪掉，被裁剪掉的坐标就不会显示，这就是裁剪坐标系的由来。
    我们将坐标全部表示成【-1.0 , 1.0】之间的方式不是很直观，所以我们希望先将观察空间中的某一部分裁剪出来，这一部分作为要显示的区域。
    比如，我们希望将各个坐标轴在 【-1000-1000】 范围内的空间区域作为可视空间区域，这一区域的所有物体都将显示到屏幕上。那么如果一个顶点 P 的坐标是（1300，500，10），那么它就会被裁剪掉，因为它没有坐落在可视空间区域。
    投影矩阵会创建一个观察箱Viewing Box，称为平截头体Frustum，出现在平截头体范围内的坐标最终都会显示在屏幕上。裁剪坐标系中的坐标转化到标准化设备坐标系的过程就很容易，这个过程被称之为投影Projection，使用投影矩阵能将 3D 坐标投影很容易地映射到 2D 的标准设备坐标系中。
    将观察坐标变换为裁剪坐标的投影矩阵可以为两种不同的形式，每种形式都定义了不同的平截头体。
    1、正射投影矩阵
      又名正交投影，正射投影矩阵创建的是一个立方体的观察箱，它定义了一个裁剪空间，在该裁剪空间之外的坐标都会被丢弃。 正射投影矩阵需要指定观察箱的长度、宽度和高度。
      经过正射投影矩阵映射后的坐标 w 分量不会改变，始终是 1，所以在经过透视除法后物体的轮廓比例不会发生改变，这种投影一般用在建筑施工图纸中，不符合人眼观察世界所产生的近大远小的规律。 所以就有了另一种投影：透视投影。
      正交投影，又名平行投影，常用在机械制图、施工图纸领域，投影后的比例和投影前的比例一致。
    2、透视投影矩阵
      实际生活中给人带来的感觉是，离我们越远的东西看起来更小。这个奇怪的效果称之为透视Perspective，透视的效果在我们看远处时尤其明显，比如下图：
      实际上，远处的群山是比近处的房屋大的，但是人眼看上去，群山比房屋小，这就是透视投影要实现的效果。
      透视投影矩阵将给定的平截头体范围映射到裁剪空间，除此之外它还会修改每个顶点坐标的 w 值，使得离人眼越远的物体的坐标 w 值越大。被变换到裁剪空间的坐标都会在 -w 到 w 的范围之间（任何大于这个范围的坐标都会被裁剪掉）。WebGL 要求所有可见的坐标都落在【-1.0 - 1.0】范围内，因此，一旦坐标转换到裁剪空间，透视除法就会被应用到裁剪坐标上。
      透视除法要求顶点坐标的每个分量除以它的 W 分量，距离观察者越远，顶点坐标也就会越小，这就是 W 分量非常重要的另一个原因，它能够帮助我们进行透视投影，经过透视除法后，所有在【-W，W】范围内的坐标都会被转变到 NDC 坐标系中。
      透视投影需要设置近平面、远平面、透视深度。
      透视投影多用在成像领域，比如人看世界、相机拍照等场景，这个场景有一个特点就是投影后能够实现近大远小的效果。
  7、NDC 坐标系
    一旦所有顶点被变换到裁剪空间，GPU 会对裁剪坐标执行透视除法，在这个过程中 GPU 会将顶点坐标的 X，Y，Z 分量分别除以齐次 W 分量。这一步会在每一个顶点着色器运行的最后被自动执行。最终所有坐标分量的范围都会在【-1，1】之间，超出这个范围的坐标都将被 GPU 丢弃。
    NDC 坐标系遵循左手坐标系，Z 轴朝向屏幕里面，Z轴值越小，越靠近我们的眼睛，我们可以通过开启 WebGL 的深度检测机制验证。
  8、屏幕坐标系
    有了 NDC 坐标之后，GPU 会执行最后一步变换操作，视口变换，这个过程会将所有在【-1, 1】之间的坐标映射到屏幕空间中，并被变换成片段。
    我们的模型历尽九九八十一难，终于显示到了屏幕上。
20、顶点从一个坐标系转换到另一个坐标系，只需要计算出这几点就可以：
  计算出原坐标系的原点 O 在新坐标系的坐标。（平移变换）
  计算出新坐标系坐标分量的单位向量在原坐标系下的长度。（缩放变换）
  计算出原坐标系的坐标分量（基向量）的方向。（旋转变换）
  看到平移、缩放、旋转，我们立刻想到了一种快速执行复杂计算的工具：矩阵。
21、在学习矩阵变换时，一定要搞清楚以下三点：
  1、所使用的向量是行向量还是列向量。
    如果是行向量，按照数学领域中矩阵相乘的规则，向量要放在左侧相乘。
    如果是列向量，向量要放在右侧相乘。
  2、矩阵是行主序还是列主序。
    如果是行主序，内存存储矩阵的数组的前四个元素表示的是对应数学矩阵的第一行
    如果是列主序，内存存储矩阵的数组的前四个元素表示的是对应数学矩阵的第一列
  3、多个矩阵变换时的相乘顺序。
    在多个矩阵变换时，不同的相乘顺序会导致不同的结果，所以我们要保证矩阵相乘的顺序是我们期望的。假设有三个变换矩阵：旋转矩阵 R，平移矩阵 T，缩放矩阵 S，以及顶点向量 P，那么 P 变换到 P1 的顺序一般是这样的：
    P1 = T x R x S x P
    即先缩放，再旋转，最后平移。
23、齐次坐标的用处：
  1、能够区分点和向量。
  2、模拟透视投影效果。
  3、用矩阵来表示平移变换。
24、在 3D 编程中，可控制的坐标系变换分为3类，分别是：
  模型变换：模型变换负责将模型坐标转换成世界坐标。
    模型变换是由多个基本变换组合而成，那么对矩阵而言，就是由多个基本变换矩阵相乘而得到，既然提到相乘，那么相乘的顺序就至关重要，因为矩阵不满足交换律，两个矩阵相乘顺序不同，结果也不同。体现到坐标系变换上，就会发现模型经过变换后的坐标也不同，这一点很重要，请大家一定要牢记。
    3D 世界中会有很多模型，每个模型所处的位置和朝向都不一样，这就需要我们对它们进行安放，模型变换就是我们安放模型的手段。
  视图变换：视图变换负责将世界坐标转换成相机坐标。
    观察空间是从人眼或者摄像机看到的 3D 空间，是整个3D 世界的一部分，观察变换的主要作用是将模型的顶点坐标从世界坐标系变换到观察坐标系中。观察坐标系也可以理解为相机坐标系。观察空间也称为相机空间。
    世界空间转变到观察空间这个过程通常称为视图变换，变换矩阵称为视图矩阵（观察矩阵）。在做视图变换之前，我们会在世界坐标系里指定摄像机或者人眼的位置eyePosition，以及摄像机头顶方向向量upDirection，然后我们要根据这两个条件计算出视图变换矩阵。
  投影变换：投影变换负责将相机坐标转换成裁剪坐标，也就是将 3D 坐标投影到 2D 平面上。
    投影变换，顾名思义，就是将 3D 坐标投影到 2D 平面的过程。观察空间沿用了右手坐标系，即 Z轴正向朝向屏幕外侧，但是裁剪坐标系是左手坐标系，即 Z 轴正向朝向屏幕内侧，那么在投影变换阶段，我们除了要将 3D 坐标投影到 2D 平面，还要将右手坐标系变换成左手坐标系。
    正交投影和透视投影的原理大体相同，基本过程如下：
      1、首先指定可视范围，即什么范围内的物体能投影。此过程通过指定近平面和远平面来圈定范围。
      2、将可视范围内的所有物体坐标投影到近平面上，投影后的坐标根据相似三角形原理求得，比较简单。
      不同之处：
      1、正交投影的投影线是平行线，可视范围是一个立方体盒子。
      2、透视投影的投影线是相交线，可视范围是一个棱锥体盒子，这样经过投影后才能达到近大远小的效果。
  需要强调一点变换矩阵相乘的顺序，假设最终变换矩阵为 F，模型矩阵为 M， 视图矩阵为 V，投影矩阵为 P，那么有：F = P x V x M
25、影响投影的因素有如下几个：
  摄像机所在位置，距离越远，投影越小，反之，投影越大。
  投影盒宽高比会影响显示比例。
  视角会影响显示大小，视角越大，投影越小，反之，投影越大。
